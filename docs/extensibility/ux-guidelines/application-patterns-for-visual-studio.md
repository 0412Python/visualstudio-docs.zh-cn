---
title: "Visual Studio 的应用程序模式 |Microsoft 文档"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- vs-ide-sdk
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
caps.latest.revision: 7
ms.author: gregvanl
manager: ghogen
translation.priority.mt:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: 5db97d19b1b823388a465bba15d057b30ff0b3ce
ms.openlocfilehash: 83b586273dcc60f56ad81fd451adce7860df4033
ms.lasthandoff: 02/22/2017

---
# <a name="application-patterns-for-visual-studio"></a>Visual Studio 的应用程序模式
##  <a name="a-namebkmkwindowinteractionsa-window-interactions"></a><a name="BKMK_WindowInteractions"></a>窗口的交互  
  
### <a name="overview"></a>概述  
 在 Visual Studio 中使用的两个主窗口类型了文档的编辑器和工具窗口。 少见，但有可能是较大的无模式对话框。 尽管这些是在外壳程序中所有无模式，其模式是完全不同。 本主题介绍的文档窗口、 工具窗口和无模式对话框之间的差异。 中介绍了模式对话框模式[对话框](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)。  
  
### <a name="comparing-window-usage-patterns"></a>比较窗口使用模式  
 **文档窗口**几乎总是也显示在文档中。 这样，文档编辑器"center 阶段"若要排列周围的补充工具窗口。  
  
 一个**工具窗口**最通常都以单独、 容量较小的窗口 – 它可以是可见、 隐藏或自动隐藏 – 折叠靠着一 IDE 形式显示。 但是，有时它们是在文档内显示好吧，通过取消选中**窗口/停靠**窗口上的属性。 这将导致更多空间，但也一种常见设计决策︰ 在尝试将集成到 Visual Studio 时，您必须确定您的功能是否应显示一个工具窗口或文档窗口。  
  
 **无模式对话框**不鼓励在 Visual Studio 中。 到很大程度上，它们 – 定义 – 通过浮动工具窗口，并且应将按如下方式实现。 在正常的工具窗口停靠到的外壳程序的一侧的大小将会过于受限的情况下允许无模式对话框。 它们还允许在用户将可能会将对话框中移动到第二个监视器的情况下。  
  
 考虑仔细何种容器类型需要。 UI 设计的常见使用模式需要考虑以下几点下表中。  
  
||文档窗口|工具窗口|无模式对话框|  
|-|---------------------|-----------------|---------------------|  
|**位置**|始终定位在文档中也并不停靠在 IDE 的边缘周围。 它可以被"拉入"以使它浮动分别从主外壳程序。|通常在 IDE 的边缘周围停靠选项卡上，但可以是自定义以浮点值、 自动隐藏 （不驻留） 或也停靠在文档中。|独立于 IDE 的大型浮动窗口。|  
|**提交模型**|*延迟的提交*<br /><br /> 若要将数据保存在文档中，用户必须发出文件/保存、 另存为或全部保存命令。 然后提交一次保存到它正在"更新"中的数据的概念，文档窗口具有命令。 当关闭文档窗口时，所有内容都保存到磁盘，或者丢失。|*立即提交*<br /><br /> 没有任何保存模型。 帮助编辑文件检查器工具窗口，必须先在活动编辑器或设计器中，打开文件和编辑器或设计器负责保存。|*延迟或立即提交*<br /><br /> 大多数情况下，较大的无模式对话框不需要采取措施以提交更改，并允许一个"取消"操作，从而回滚在对话会话中进行了任何更改。  在于这是无模式对话框从工具窗口中，工具窗口始终能够立即提交模型。|  
|**可见性**|*打开/创建 （文件） 并关闭*<br /><br /> 打开文档窗口是通过打开现有文档或使用模板来创建新文档。 没有任何"打开\<特定编辑器&1;>"命令。|*隐藏和显示*<br /><br /> 单实例工具窗口可以显示或隐藏。 内容和工具窗口内的状态保留是否在视图中的还是隐藏。 多实例工具窗口可以被关闭，以及隐藏。 多实例工具窗口关闭时，内容和工具窗口中的状态将被丢弃。|*从命令启动*<br /><br /> 从基于任务的命令启动对话框。|  
|**实例**|*多个实例*<br /><br /> 当某些编辑器还允许在多个编辑器中打开同一个文件时，可以在同一时间和编辑不同的文件，打开多个编辑器 (使用**窗口&1;> 新窗口**命令)。<br /><br /> 在同一时间 （项目设计器），单个编辑器可能正在编辑的一个或多个文件。|*单-或多-instance*<br /><br /> 内容会更改为反映上下文 （如在属性浏览器） 或将焦点/上下文推送到其他窗口 （解决方案资源管理器中的任务列表）。<br /><br /> 如果没有人信服的理由不到，单实例和多实例工具窗口应与活动文档窗口相关联。|*单实例*|  
|**示例**|**文本编辑器**，如代码编辑器<br /><br /> **设计图面**，如窗体设计器或建模图面<br /><br /> **控制布局类似于对话框**，如清单设计器|**解决方案资源管理器**提供了一个解决方案和解决方案中包含的项目<br /><br /> **服务器资源管理器**提供用户选择的窗口中打开的服务器和数据连接的分层视图。 从数据库层次结构，如查询中，打开对象打开的文档窗口，并允许用户编辑查询。<br /><br /> **属性浏览器**显示在文档窗口或另一个工具窗口中的所选对象的属性。 属性在层次结构的网格视图中或在复杂的类似对话框的控件提供，并允许用户设置这些属性的值。||  
  
##  <a name="a-namebkmktoolwindowsa-tool-windows"></a><a name="BKMK_ToolWindows"></a>工具窗口  
  
### <a name="overview"></a>概述  
 工具窗口支持发生在文档窗口中的用户的工作。 它们可以用于显示表示 Visual Studio 提供，并可以操作的基本根对象的层次结构。  
  
 在考虑新的工具窗口在 IDE 中，作者应︰  
  
-   使用适合任务的现有工具窗口并不是重新创建具有类似功能。 如果他们提供明显不同的"工具"或功能，不能将其集成到一个类似的窗口，或通过将现有的窗口转变为透视的集线器，应该仅创建新的工具窗口。  
  
-   使用标准命令栏中，如果需要请在工具窗口的顶部。  
  
-   与已存在于其他工具窗口的控件演示文稿和键盘导航模式保持一致。  
  
-   与其他工具窗口中的控件演示文稿保持一致。  
  
-   以便它们显示仅在激活的父文档时，特定于文档的工具窗口应自动可见在可能的情况。  
  
-   请确保其窗口内容可通过键盘 （支持箭头键） 导航。  
  
#### <a name="tool-window-states"></a>工具窗口状态  
 Visual Studio 工具窗口具有不同的状态，其中一些用户激活 （例如，自动隐藏功能）。 其他状态，如自动可见，请允许工具窗口，以正确的上下文中显示和隐藏时不需要。 总共有五个工具窗口状态。  
  
-   **停靠固定**工具窗口可以附加到任何文档区域的四个边。 图钉图标将出现在工具窗口标题栏。 工具窗口可以靠接水平或垂直边缘的外壳和其他工具窗口，并且也可以链接到选项卡。  
  
-   **自动隐藏**工具窗口都已取消固定。 窗口可以滑动到视线之外，离开 （带有工具窗口的名称和它的图标） 的选项卡上的文档区域的边缘。 工具窗口中滑出，当用户悬停在选项卡上。  
  
-   **自动可见**在 UI 中，另一幅如编辑器中，将启动，或获得焦点时自动显示工具窗口。  
  
-   **浮点**工具窗口将鼠标悬停在 IDE 之外。 这可用于多监视器配置。  
  
-   **选项卡式的文档**工具窗口可以停靠在文档内良好。 这是帧的对于大型的工具窗口，如对象浏览器中，需要更多房地产多于停靠到边缘允许非常有用。  
  
 ![工具窗口状态在 Visual Studio 中的](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702年&01;_ToolWindowStates")  
  
 **在 Visual Studio 中的工具窗口状态**  
  
#### <a name="single-instance-and-multi-instance"></a>单实例和多实例  
 工具窗口是单实例还是多个实例。 在多实例工具窗口可能不会时，可能与活动文档窗口中，关联的某些单实例工具窗口。 多实例工具窗口响应窗口 / 新建窗口命令，通过创建窗口中的新实例。 下图阐释了一个工具窗口，使新窗口命令窗口中的实例处于活动状态时︰  
  
 ![启用 Visual Studio 中的命令工具窗口](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702年&02;_ToolWindowEnablingCommand")  
  
 **启用新窗口命令窗口中的实例时工具窗口处于活动状态**  
  
 单实例工具窗口可以隐藏或显示，而多实例工具窗口可以被关闭，以及隐藏。 所有工具窗口可以都停靠，链接到选项卡、 浮动状态，或设置为多文档界面 (MDI) 子窗口 （类似于一个文档窗口）。 所有工具窗口应都响应窗口菜单中的合适的窗口管理命令︰  
  
 ![在 Visual Studio 中的窗口管理命令](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702年&03;_WindowManagementControls")  
  
 **在 Visual Studio 窗口菜单中的窗口管理命令**  
  
#### <a name="document-specific-tool-windows"></a>特定于文档的工具窗口  
 某些工具窗口用于根据给定类型的文档发生更改。 这些窗口，不断更新以反映功能适用于 IDE 中的活动文档窗口。  
  
 其内容发生更改以反映所选的编辑器的工具窗口的示例包括工具箱中和文档大纲。 这些窗口将显示一个水印编辑器具有焦点并不提供到窗口的上下文时。  
  
#### <a name="navigable-list-tool-windows"></a>可导航列表工具窗口  
 某些工具窗口显示用户可以与交互的可导航项的列表。 在此类型的窗口中，应始终有反馈当前项在列表中，即使该窗口处于非活动状态。 列表应响应**GoToNextLocation**和**GoToPrevLocation**命令也可更改窗口中的当前选定的项  
  
 可导航列表工具窗口的示例包括解决方案资源管理器和查找结果窗口。  
  
### <a name="tool-window-types"></a>工具窗口类型  
  
#### <a name="common-tool-windows-and-their-functions"></a>常用的工具窗口和其函数  
  
|类型|工具窗口|函数|  
|----------|-----------------|--------------|  
|**层次结构**|“解决方案资源管理器”|层次结构树中显示的文档的列表包含在项目、 杂项文件和解决方案项。 由拥有该项目类型 （例如，基于引用的、 基于目录的或混合模式类型） 的包定义的项目中项的显示。|  
|**层次结构**|类视图|类和文档，文件本身的独立的工作集中的各个元素的分层树。|  
|**层次结构**|服务器资源管理器|层次结构树中显示的所有服务器和数据连接解决方案中的说明。|  
|**层次结构**|文档大纲|活动文档层次结构。|  
|**网格**|属性|显示网格中编辑这些属性的值选取器以及所选对象的属性的列表。|  
|**网格**|任务列表|一个网格，使用户可以创建、 编辑或删除任务和批注。|  
|**内容**|帮助|一个窗口，允许各种方法获取帮助，从"我如何"的访问权限的用户 MSDN 论坛的视频。|  
|**内容**|动态帮助|工具窗口，其中显示链接到帮助主题适用于当前所选内容。|  
|**内容**|对象浏览器|在左的窗格和对象的属性层次结构对象组件和右侧列中的方法的列表包含两列框架集。|  
|**对话框**|查找高级查找|一个对话框，用户可以查找或查找和替换在解决方案中的各种文件中。|  
|**其他**|工具箱|用于存储将放置到设计图面，为所有设计器提供一致的拖动源上的元素的工具窗口。|  
|**其他**|起始页|用户的门户向 Visual Studio 中，有权访问的开发人员新闻、 Visual Studio 帮助和最近的项目的源。 用户还可以创建自定义起始页将 StartPage.xaml 文件从"Common7\IDE\StartPages\"Visual Studio 程序文件目录复制到的 StartPages 文件夹中 Visual Studio 文档目录中，然后手动编辑 XAML 或打开在 Visual Studio 或另一个代码编辑器。|  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|自动||  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|即时||  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|输出|如果您有文本事件或状态来声明，则可以使用输出窗口。|  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|内存||  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|断点||  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|正在运行||  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|文档||  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|调用堆栈||  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|局部变量||  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|监视点||  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|反汇编||  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|寄存器||  
|**调试器︰**的特定于调试任务和监视活动的 windows 组|线程||  
  
##  <a name="a-namebkmkdocumenteditorconventionsa-document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a>文档编辑器约定  
  
### <a name="document-interactions"></a>文档交互  
 "文档以及"是在 IDE 中的最大空间，其中用户通常一直致力于他们的注意若要完成其任务，当然还少不了补充工具窗口。 文档编辑器表示用户打开和保存 Visual Studio 中的工作的基本单元。 它们仍然保留了明确识别的选择会绑定到解决方案资源管理器或其他活动的层次结构窗口。 用户应能够指向这些层次结构窗口中的一个解决方案、 项目或由 Visual Studio 程序包提供的另一个根对象知道其中包含的文档和它的关系。  
  
 文档编辑需要一致的用户体验。 若要允许用户可以专注于手头的任务而不是在窗口管理和查找命令上，选择最适合用于编辑该文档类型的用户任务的文档视图策略。  
  
#### <a name="common-interactions-for-the-document-well"></a>文档很常见的交互  
  
-   维护一致的交互模型共同**新文件**和**打开的文件**体验。  
  
-   在文档窗口打开后，请更新相关的窗口和菜单中的相关的功能。  
  
-   菜单命令已适当地集成到常用菜单如**编辑**，**格式**，和**视图**菜单。 如果大量的专用命令都不可用，则可以即可见仅当该文档具有焦点时，才创建新菜单。  
  
-   嵌入式工具栏上可能会放置在编辑器的顶部。 这是更可取的方法使其显示在编辑器外的单独工具栏。  
  
-   始终保持在解决方案资源管理器或类似活动中的选择层次结构窗口。  
  
-   双击解决方案资源管理器中的文档应执行相同的操作**打开**。  
  
-   如果可以在文档类型上使用多个编辑器，用户应该能够重写或重置给定的文档类型使用的默认操作**打开**对话框中，右键单击该文件并选择**打开**从快捷菜单。  
  
-   也不生成文档中的向导。  
  
### <a name="user-expectations-for-specific-document-types"></a>用户期望为特定文档类型的  
 有多种不同的基本类型的文档编辑器，每个都有一组交互与相同类型的其他人相一致。  
  
-   **基于文本的编辑器︰**的代码编辑器、 日志文件  
  
-   **设计图面︰** WPF 窗体设计器中，Windows 窗体  
  
-   **对话框样式编辑器︰**清单设计器中，项目属性  
  
-   **模型设计器︰**工作流设计器、 codemap、 体系结构关系图、 进度  
  
 也有几种也使用该文档的非编辑器类型。 尽管它们不编辑文档本身，他们需要遵循文档窗口的标准交互操作。  
  
-   **报表︰** IntelliTrace 报告，Hyper-v 的目标报表中，探查器报告  
  
-   **仪表板︰**诊断中心  
  
#### <a name="text-based-editors"></a>基于文本的编辑器  
  
-   文档参与预览选项卡上模型中，从而使预览文档，而无需打开它。  
  
-   在配套工具窗口，如文档大纲中，可以表示文档的结构。  
  
-   IntelliSense （如果适用） 将与其他代码编辑器行为保持一致。  
  
-   弹出窗口或辅助 UI 为现有类似的 UI，如 CodeLens 按照类似的样式和图案。  
  
-   在文档顶部的信息栏控件中或在状态栏中，将提供有关文档状态消息。  
  
-   用户必须能够自定义的字体和颜色使用外观**工具&1;> 选项**页上，共享的字体和颜色页面或一个特定于编辑器中。  
  
#### <a name="design-surfaces"></a>设计图面  
  
-   空的设计器图面，该值指示如何开始上应有水印。  
  
-   视图切换机制将遵循现有的模式，例如双击以打开代码编辑器中或在文档窗口允许与这两个窗格之间的交互中的选项卡。  
  
-   应该通过工具箱中，完成将元素添加到设计图面上，除非是必需的针对性极强的工具窗口。  
  
-   面上的项将遵循一致的所选内容模型。  
  
-   嵌入的工具栏包含特定于文档的命令仅、 不是公共命令如**保存**。  
  
#### <a name="dialog-style-editors"></a>对话框样式编辑器  
  
-   控件布局应遵循标准的对话框布局约定。  
  
-   在编辑器中的选项卡不应与文档选项卡的外观，它们应匹配的两个允许内部选项卡样式之一。  
  
-   用户必须能够与使用键盘; 这些控件交互通过使用标准的助记键激活编辑器和 tab 键切换功能通过控件或任意一个。  
  
-   设计器应使用的常见保存模型。 没有总体保存或提交按钮应会放表面上看，尽管其他按钮可能比较适当。  
  
#### <a name="model-designers"></a>模型设计器  
  
-   空的设计器图面，该值指示如何开始上应有水印。  
  
-   将元素添加到设计图面上时，应该通过工具箱来完成。  
  
-   面上的项将遵循一致的所选内容模型。  
  
-   嵌入的工具栏包含特定于文档的命令仅、 不是公共命令如**保存**。  
  
-   图例可以出现在图面，指示或成为水印。  
  
-   用户必须能够使用的字体/颜色的外观进行自定义**工具&1;> 选项**页上，共享的字体和颜色页面或一个特定于编辑器中。  
  
#### <a name="reports"></a>报表  
  
-   报表是通常只信息并不参与保存模型。 但是，它们可能包括交互，例如指向其他相关信息或展开和折叠的部分。  
  
-   在图面上的大多数命令应为不按钮的超链接。  
  
-   布局应包含标头，并按照标准报表布局准则。  
  
#### <a name="dashboards"></a>面板  
  
-   仪表板并不一定交互模型本身，但作为一种方法提供了多种其他工具。  
  
-   它们不参与保存模型。  
  
-   用户必须能够与通过激活编辑器中，并在控件中按 tab 或通过使用标准的助记键使用键盘，这些控件交互。  
  
##  <a name="a-namebkmkdialogsa-dialogs"></a><a name="BKMK_Dialogs"></a>对话框  
  
### <a name="introduction"></a>介绍  
 Visual Studio 中的对话框通常应支持一个离散的用户的工作单位，然后关闭。  
  
 如果已确定你需要一个对话框，则按优先顺序有三个选项︰  
  
1.  将您的功能集成到 Visual Studio 中共享对话框之一。  
  
2.  创建对话中使用现有的类似对话框中找到的模式。  
  
3.  创建新建对话框、 以下交互和布局准则。  
  
 本主题介绍如何选择 Visual Studio 工作流中的正确对话框模式和对话框设计的通用约定。  
  
### <a name="themes"></a>主题  
 在 Visual Studio 中的对话遵循以下两种基本的样式之一︰  
  
#### <a name="standard-unthemed"></a>标准 (unthemed)  
 对话的大部分标准实用程序的对话框，并且应该 unthemed。 不要 re 模板公共控件或尝试创建风格化的"现代"按钮或控件。 控件和 chrome 外观，请按照[适用于对话框的标准 Windows 桌面的交互准则](https://msdn.microsoft.com/en-us/library/windows/desktop/dn742499\(v=vs.85\).aspx)。  
  
#### <a name="themed"></a>应用了主题  
 专业"签名"对话框可能会有主题。 主题对话框都具有独特的外观，还具有与样式相关的一些特殊的交互模式。 主题对话中仅当满足这些要求︰  
  
-   对话框中是一种通用体验，将看到并使用经常或由多个用户 (例如，**新项目**对话框。  
  
-   对话框中包含重要产品品牌元素 (例如，**帐户设置**对话框)。  
  
-   对话框中显示为一个更大的流，其中包含其他主题的对话框的组成部分 (例如，**添加连接的服务**对话框)。  
  
-   对话框中是体验的在升级或产品版本进行区分的战略作用的重要组成部分。  
  
 在创建主题对话框时，使用适当的环境颜色，并遵循正确的布局和交互模式。 (请参阅[for Visual Studio 布局](../../extensibility/ux-guidelines/layout-for-visual-studio.md))  
  
### <a name="dialog-design"></a>对话框设计  
 设计良好的对话还要考虑以下元素︰  
  
-   支持用户任务  
  
-   对话框文本样式、 语言和术语  
  
-   控件选择和 UI 约定  
  
-   可视布局规范和控件的对齐方式  
  
-   键盘访问  
  
#### <a name="content-organization"></a>内容组织  
 请考虑对话框这些基本类型之间的差异︰  
  
-   [简单对话框](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs)存在一个单一的模式窗口中的控件。 此演示文稿可能包括复杂的控件模式，包括字段选择器或图标栏的变体。  
  
-   [分层对话框](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs)用于充分利用屏幕空间，当一段单独的 UI 包含多个组中的控件时。 对话框中的分组已"分层"通过选项卡控件、 导航列表控件或按钮，以便用户可以选择要查看在任意给定时刻的分组。  
  
-   [向导](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards)可用于指导用户完成的步骤来完成任务的逻辑顺序。 在顺序面板，有时会引入不同的工作流 （"分支"） 依赖于在上一面板中所做的选择中提供了一系列选择。  
  
####  <a name="a-namebkmksimpledialogsa-simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a>简单对话框  
 简单对话框是一个模式窗口中的控件的演示文稿。 此演示文稿可能包含变体的复杂控件模式，如域选取器。 简单对话框，请遵循标准的常规布局以及任何所需的复杂控件分组的特定布局。  
  
 ![Visual Studio 中的简单对话框](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704年&01;_CreateStrongNameKey")  
  
 **创建强名称密钥是一个简单的对话框在 Visual Studio 中的一个示例。**  
  
####  <a name="a-namebkmklayereddialogsa-layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a>分层的对话框  
 分层的对话框包括选项卡、 仪表板和嵌入式的树。 它们用于来最大化房地产控件在一段单独的用户界面中提供的多个组。 分组已分层，以便用户可以选择分组的若要查看一次。  
  
 在最简单的情况下，用于分组之间进行切换的机制是选项卡控件。 有多种替代方法。 请参阅优先级和如何选择最合适的样式的分层。  
  
 **工具&1;> 选项**对话框是举例说明如何使用嵌入的树的分层对话框︰  
  
 ![Visual Studio 中的分层的对话框](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704年&02;_ToolsOptions")  
  
 **工具&1;> 选项是举例说明如何在 Visual Studio 中的分层对话框。**  
  
####  <a name="a-namebkmkwizardsa-wizards"></a><a name="BKMK_Wizards"></a>向导  
 向导可用于在任务完成指导用户完成一系列逻辑的步骤。 选择一系列提供连续面板中，用户必须继续下一次每个步骤均在继续操作之前完成。 一旦足够的默认值，则有**完成**按钮才可用。  
  
 任务使用模式的向导的︰  
  
-   包含分支，具体取决于用户选择提供不同的路径的位置  
  
-   包含的步骤中，其中的后续步骤依赖于前面步骤中的用户输入之间的依赖关系  
  
-   已经够复杂 UI 应该用于说明提供的选项以及每个步骤中可能的结果  
  
-   是事务性的这需要一套提交任何更改之前完成其作为一个整体的步骤  
  
### <a name="common-conventions"></a>公共约定  
 若要实现最佳的设计和功能与您对话，并遵照这些约定对话框大小、 位置、 标准、 控制配置和对齐方式、 用户界面文本、 标题栏、 控制按钮和访问密钥。  
  
 布局特定的准则，请参阅[for Visual Studio 布局](../../extensibility/ux-guidelines/layout-for-visual-studio.md)。  
  
#### <a name="size"></a>大小  
 对话框应适合较小的 1024 x 768 屏幕分辨率和初始对话框大小不应超过 900 x 700 像素为单位。 对话框可能可调整大小，但它并不要求。  
  
 有两个建议可调整大小对话框︰  
  
1.  最小大小是定义为对话框中，将为控件集，而不出现剪切，优化和调整以适应合理本地化增长。  
  
2.  用户缩放大小仍然存在于会话之间。 例如，如果用户按比例为 150%一个对话框，则对话框的后续发布将显示在 150%。  
  
#### <a name="position"></a>位置  
 对话框必须出现在首次启动 IDE 内居中。 对于非可调整大小对话框，它不是必需的对话框中的最后一个位置将保持不变，因此它将出现在后续启动上居中。 可调整大小对话框的大小应保持在后续启动。 可调整大小都是模式对话框的对话框，不需要保留位置。 它们在 IDE 中居中显示可防止对话框中出现不可预知的或不可用的位置，当用户的显示配置发生更改时的可能性。 可重新定位的无模式对话框，用户的位置应上执行维护后续启动，如对话框中可通常用作较大工作流的组成部分。  
  
 当对话框必须生成其他对话框时，最顶端对话框中应级联向右和向下从父节点使其明白他们已导航至新位置的用户。  
  
#### <a name="modality"></a>模态  
 正在模式意味着用户所需完成或取消对话框中，然后再继续。 由于模态对话框阻止用户与环境中的其他部分进行交互，功能的任务流应尽可能谨慎地使用它们。 需要模式操作时，Visual Studio 提供许多共享对话框，您可以将集成到您的功能。 如果必须创建一个新的对话框，请按照现有的对话的交互模式，具有类似功能。  
  
 当用户需要执行两个活动在执行一次，如**查找**和**替换**当编写新代码，对话框中应为无模式，以便用户可以轻松地它们之间进行切换。 Visual Studio 通常使用此类型的编辑器支持链接的任务的工具窗口。  
  
#### <a name="control-configuration"></a>控制配置  
 与完成同样的操作在 Visual Studio 中的现有控件配置保持一致。  
  
#### <a name="title-bars"></a>标题栏  
  
-   在标题栏中的文本必须反映启动它的命令的名称。  
  
-   应在对话框的标题栏中使用无图标。 系统要求一个位置的情况下，使用 Visual Studio 徽标。  
  
-   对话框不应具有最大程度减少或最大化按钮。  
  
-   标题栏中的帮助按钮已被否决。 不要将它们添加到新的对话框。 当它们确实存在时，他们应启动是在概念上与任务相关联的帮助主题。  
  
 ![标题栏 Visual Studio 的规范](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704年&03;_TitleBarSpecs")  
  
 **在 Visual Studio 对话框中的标题栏的指导原则规范。**  
  
#### <a name="control-buttons"></a>控件按钮  
 一般情况下，**确定**/**取消**/**帮助**按钮应在该对话框右下角中水平排列。 如果对话框有几个其他按钮会出现与控制按钮的视觉混淆的对话框底部，则允许备用垂直堆栈。  
  
 ![控制在 Visual Studio 中的按钮配置](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704年&04;_ControlButtonConfig")  
  
 **可接受 Visual Studio 对话框中的控件按钮配置**  
  
 对话框中必须包括默认控件按钮。 若要确定最佳的命令，以便使用作为默认值，请选择从以下选项 （按优先级顺序列出）︰  
  
-   为默认选择安全也是最安全的命令。 这意味着选择最有可能以防止数据丢失并避免意外的系统访问权限的命令。  
  
-   如果数据丢失和安全性不因素，然后选择基于方便使用的默认命令。 对话框支持频繁或重复的任务时，包括默认值为最可能的命令将提高用户的工作流。  
  
 避免选择用于默认命令的永久破坏性操作。 如果存在此类命令，则更安全的命令为默认值改为选择。  
  
#### <a name="access-keys"></a>访问键  
 不使用访问键**确定**/**取消**/**帮助**按钮。 默认情况下，这些按钮映射到键盘快捷方式︰  
  
|按钮名称|键盘快捷方式|  
|-----------------|-----------------------|  
|确定|Enter|  
|取消|Esc|  
|帮助|F1|  
  
#### <a name="imagery"></a>图像  
 在对话框中应谨慎使用映像。 不要使用大图标的对话框中仅为使用占用的空间。 仅当它们是传达给用户，如警告图标或状态动画消息的重要组成部分，请使用图像。  
  
###  <a name="a-namebkmkprioritizingandlayeringa-prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a>优先级并对其分层  
  
#### <a name="prioritizing-your-ui"></a>确定您的 UI 的优先级  
 它可能需要某些用户界面元素置于前端，更高级的行为和到对话框选项 （包括不明显的命令）。 为 forefront 提供常用的功能，通过使腾出空间供它，并使其可见的文本标签与用户界面中默认情况下显示对话框时。  
  
#### <a name="layering-your-ui"></a>分层用户界面  
 如果您确定一个对话框，对话框是必需的但您想要向用户显示的相关的功能远不止简单的对话框中可以显示的内容，则需要进行分层您的 UI。 Visual Studio 将使用的最常见的分层方法是选项卡和过道帖子或仪表板。 在某些情况下，可以展开和折叠的区域可能正合适。 在 Visual Studio 中通常不建议自适应 UI。  
  
 有一些优点和缺点的分层用户界面通过类似于选项卡上的控件的不同方法。 检查以确保您选择的一种分层方法，适合于您的具体情况，下面的列表。  
  
##### <a name="tabbing"></a>Tab 键次序  
  
|交换机制|优势和适当的用法|缺点以及使用不当|  
|-------------------------|------------------------------------|-----------------------------------------|  
|Tab 控件|为相关集集按逻辑组对话框页面<br /><br /> 适用于少于五个 （或对话框中调整在一行中的选项卡的数目） 对话框中的相关控件的页面<br /><br /> 选项卡标签必须很短︰ 可以轻松地识别的内容的一个或两个单词<br /><br /> 常见的系统对话框样式<br /><br /> 示例︰**文件资源管理器&1;> 项属性**|很难进行简短的说明性标签<br /><br /> 通常不能缩放过去的五个选项卡在一个对话框<br /><br /> 如果您有太多的选项卡一行; 不适合使用备用的分层方法<br /><br /> 不可扩展|  
|边栏导航|可以容纳更多类别选项卡比简单切换设备<br /><br /> 类别 （无层次结构） 的简单列表<br /><br /> 可扩展<br /><br /> 示例︰**自定义...1> 添加命令**|不是有效利用水平间距，如果少于三组<br /><br /> 任务可能是更好地适合于下拉列表|  
|树控件|允许不受限制的类别<br /><br /> 允许进行分组和/或类别的层次结构<br /><br /> 可扩展<br /><br /> 示例︰**工具&1;> 选项**|嵌入很深的层次结构可能会导致过多的水平滚动<br /><br /> Visual Studio 提供了过度使用了树视图|  
|向导|在任务完成通过指导完成基于任务的、 按顺序的步骤中最新版本。 该向导表示的高级任务，并且各个面板表示完成整个任务所需的子任务。<br /><br /> 在跨 Ui 边界，作为用户本应在何时具有可以使用多个编辑器和工具窗口来完成的任务的任务时很有用<br /><br /> 在此任务需要分支时很有用<br /><br /> 在任务中包含步骤之间的依赖关系时很有用<br /><br /> 如果可以在一个对话框，可以减少不同类似对话框展示几个与一个决定分叉类似的任务非常有用。|不适合于任何不需要的顺序工作流的任务<br /><br /> 用户可以成为不堪重负，但具有太多步骤的向导通过混淆<br /><br /> 向导本质上是具有有限的屏幕空间|  
  
##### <a name="hallways-or-dashboards"></a>过道帖子或仪表板  
 过道帖子和仪表板是对话框或充当启动指向其他对话框和窗口的面板。 设计良好的"过道"立即显示只有最常用的选项、 命令和设置，使用户能够轻松地完成常见任务。 如现实世界走廊里提供了入口，若要访问在其后面聊天室，此处不太常见 UI 收集到单独"聊天室"（通常是其他对话框） 相关的功能，可以从主走廊里进行访问。  
  
 或者，一个用户界面，而不是重构较少见功能集成到不同的位置，则只需一个仪表板提供单个集合中的所有可用的功能。  
  
 ![在 Outlook 中的过道概念](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704年&08;_Hallway")  
  
 **用于公开在 Outlook 中的其他用户界面的过道概念**  
  
##### <a name="adaptive-ui"></a>自适应 UI  
 显示或隐藏 UI 基于使用情况或用户的自助报告的体验是另一种在隐藏其他部分的同时提供必要的 UI。 这不建议在 Visual Studio 中用于确定何时显示或隐藏 UI 的算法可能比较棘手，以及这些规则将始终是错误的情况下的某些组。  
  
##  <a name="a-namebkmkprojectsa-projects"></a><a name="BKMK_Projects"></a>项目  
  
### <a name="projects-in-the-solution-explorer"></a>在解决方案资源管理器中的项目  
 大多数项目被归类为基于引用的、 基于目录的还是混合。 在解决方案资源管理器中同时支持所有三种类型的项目。 使用项目中的用户体验的根在此窗口内发生。 尽管不同的项目节点是引用、 目录或混合模式类型的项目，但是没有在拆分成特定于项目的用户模式之前应该作为起始点应用常见的交互模式。  
  
 项目应始终︰  
  
-   支持添加项目文件夹来组织项目内容的能力  
  
-   维护一致的模型项目持久性  
  
 项目还应该维护一致的交互模型︰  
  
-   删除项目项  
  
-   保存文档  
  
-   编辑项目属性  
  
-   编辑另一种视图中的项目  
  
-   拖放操作  
  
### <a name="drag-and-drop-interaction-model"></a>拖放交互模型  
 项目通常分类本身作为基于引用的 （可持久保存到存储中的项目项的唯一引用），基于目录的 （无法以物理方式保留唯一项目项存储在项目的层次结构中），或混合 （无法保留引用或物理项目）。 IDE 可容纳所有三种类型的项目，同时在**解决方案资源管理器**。  
  
 从拖放的角度看，以下特征应该应用于每种类型的项目中**解决方案资源管理器**:  
  
-   **基于引用的项目︰**关键之处在于，围绕参考中存储的项拖动项目。 当基于引用的项目可作为移动操作的源时，它只应移除对该项目从项目的引用。 不应从硬盘实际上删除该项。 时基于引用的项目可作为移动 （或复制） 操作的目标，它应添加对原始的源项的引用，而无需进行的项的私有副本。  
  
-   **基于目录的项目︰**拖放的角度来看，从该项目拖动周围的物理项而不是一个引用。 当基于目录的项目可作为移动操作的源时，它应结束从硬盘中删除物理项目，以及从项目中删除。 当基于目录的项目可作为移动 （或复制） 操作的目标时，它应在其目标位置生成一份源项。  
  
-   **多重目标项目︰**从拖放的角度来看，此类型的项目的行为取决于 （向存储中的项的引用），或者针对项本身所拖动的项的性质。 上面介绍了引用和物理项目的正确行为。  
  
 只有一种类型的项目中好像**解决方案资源管理器**，然后拖放操作很简单。 由于每个项目系统具有定义自己的拖放行为的能力，应遵循某些准则 （基于 Windows 资源管理器拖放行为） 以确保可预见的用户体验︰  
  
-   未修改拖动操作**解决方案资源管理器**（当 Ctrl 和 Shift 键都不按下） 会导致移动操作。  
  
-   按住 shift 并拖动操作还会在移动操作。  
  
-   按住 Ctrl 并拖动操作应导致复制操作。  
  
-   基于引用的和混合项目系统支持到源项添加链接 （或引用） 的概念。 当这些项目都拖放操作的目标 (当**Ctrl + Shift**是否按下)，它会导致对添加到项目中的项的引用  
  
 并非所有的拖放操作都是合理的基于引用的、 基于目录的和混合项目组合。 特别是，它会带来问题，假设以允许基于目录的源项目和基于引用的目标项目之间移动操作，因为源基于目录的项目必须删除在移动完成后的源项。 然后最终目标基于引用的项目会得到对已删除项的引用。  
  
 它也是令人误解假设以允许这些类型的项目之间的复制操作，因为目标基于引用的项目不应作为源项的独立副本。 同样，Ctrl + Shift 拖动到基于目录的目标项目不应允许由于基于目录的项目是，无法保留的引用。 在其中不支持拖放操作的情况下，IDE 应不允许删除，并向用户显示非放置光标 （下面指针表中所示）。  
  
 若要正确实现拖放行为，请拖动源项目需要通信本质 （例如，它是基于引用或目录的吗？） 到目标项目。 此信息由源提供的剪贴板格式表示。 作为拖动 （或剪贴板复制操作） 的源项目应提供任何一个**CF_VSREFPROJECTITEM**S 或**CF_VSSTGPROJECTITEMS**分别根据该项目是基于引用的还是基于目录的。 这两种格式具有相同的数据内容，这类似于 Windows **CF_HDROP**设置的格式，但列表的字符串，而不是文件名是双-**NULL**终止列表**Projref**字符串 (如从返回**IVsSolution::GetProjrefOfItem**或**:: GetProjrefOfProject**视情况而定)。  
  
 作为拖放 （或剪贴板粘贴操作） 的目标，一个项目应同时接受**CF_VSREFPROJECTITEMS**和**CF_VSSTGPROJECTITEMS**，但拖放操作的完全处理的目标项目和源代码项目的性质而异。 源项目是否提供声明它的性质**CF_VSREFPROJECTITEMS**或**CF_VSSTGPROJECTITEMS**。 拖放目标了解它自己的性质，因此有足够的信息来决定与是否移动、 复制、 或链接应执行。 用户还会修改哪个拖放操作应执行通过按 Ctrl、 shift 键，或同时 Ctrl 和 Shift 键。 放置目标来正确地表明将提前在执行哪些操作非常重要其**DragEnter**和**DragOver**方法。 **解决方案资源管理器**会自动获知，源项目和目标项目是否是同一个项目。  
  
 特别是不支持 （例如，从的 devenv.exe 到另一个实例） 在 Visual Studio 的实例之间拖动项目项。 **解决方案资源管理器**还直接将禁用此。  
  
 用户应始终能够通过选择某一项，将其拖到目标位置，并观察的跟随鼠标指针将显示在删除项之前确定拖放操作的效果︰  
  
|鼠标指针|命令|描述|  
|-------------------|-------------|-----------------|  
|![鼠标"不放下"图标](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706年&01;_MouseNoDrop")|不停机|项不能被放到指定的位置。|  
|![鼠标"复制"图标](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706年&02;_MouseCopy")|复制|将项复制到目标位置。|  
|![鼠标"移动"图标](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706年&03;_MouseMove")|移动|项将移到目标位置。|  
|![鼠标"添加引用"图标](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706年&04;_MouseAddRef")|添加引用|对所选的项的引用将添加到目标位置。|  
  
#### <a name="reference-based-projects"></a>基于引用的项目  
 下表总结了，应根据基于引用的目标项目的情况下按下的源项和修改键特性的拖放 （以及剪切/复制/粘贴） 操作︰  
  
|||源项︰ 引用/链接|源项︰ 物理项目或文件系统 (CF_HDROP)|  
|-|-|----------------------------------|-------------------------------------------------------------|  
|没有修饰符|操作|移动|链接|  
|没有修饰符|目标|将引用添加到原始项目|将引用添加到原始项目|  
|没有修饰符|源|删除对原始项的引用|保留原始项目|  
|没有修饰符|结果|**DROPEFFECT_MOVE**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|**DROPEFFECT_LINK**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|  
|按住 shift + 拖动|操作|移动|不停机|  
|按住 shift + 拖动|目标|将引用添加到原始项目|不停机|  
|按住 shift + 拖动|源|删除对原始项的引用|不停机|  
|按住 shift + 拖动|结果|**DROPEFFECT_MOVE**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|不停机|  
|按住 ctrl 键 + 拖动|操作|复制|不停机|  
|按住 ctrl 键 + 拖动|目标|将引用添加到原始项目|不停机|  
|按住 ctrl 键 + 拖动|源|保留对原始项的引用|不停机|  
|按住 ctrl 键 + 拖动|结果|**DROPEFFECT_COPY**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|不停机|  
|Ctrl + Shift + 拖动|操作|链接|链接|  
|Ctrl + Shift + 拖动|目标|将引用添加到原始项目|将引用添加到原始项目|  
|Ctrl + Shift + 拖动|源|保留对原始项的引用|保留原始项目|  
|Ctrl + Shift + 拖动|结果|**DROPEFFECT_LINK**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|**DROPEFFECT_LINK**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|  
|Ctrl + Shift + 拖动|说明|Windows 资源管理器中的快捷方式拖放行为相同。||  
|剪切/粘贴|操作|移动|链接|  
|剪切/粘贴|目标|将引用添加到原始项目|将引用添加到原始项目|  
|剪切/粘贴|源|保留对原始项的引用|保留原始项目|  
|剪切/粘贴|结果|项目仍保留在存储中的原始位置|项目仍保留在存储中的原始位置|  
|复制/粘贴|操作|复制|链接|  
|复制/粘贴|源|将引用添加到原始项目|将引用添加到原始项目|  
|复制/粘贴|结果|保留对原始项的引用|保留原始项目|  
|复制/粘贴|操作|项目仍保留在存储中的原始位置|项目仍保留在存储中的原始位置|  
  
#### <a name="directory-based-projects"></a>基于目录的项目  
 下表总结了，应根据基于目录的目标项目的情况下按下的源项和修改键特性的拖放 （以及剪切/复制/粘贴） 操作︰  
  
|||源项︰ 引用/链接|源项︰ 物理项目或文件系统 (CF_HDROP)|  
|-|-|----------------------------------|-------------------------------------------------------------|  
|没有修饰符|操作|移动|移动|  
|没有修饰符|目标|复制到目标位置的项|复制到目标位置的项|  
|没有修饰符|源|删除对原始项的引用|删除对原始项的引用|  
|没有修饰符|结果|**DROPEFFECT_ 移动**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|**DROPEFFECT_ 移动**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|  
|按住 shift + 拖动|操作|移动|移动|  
|按住 shift + 拖动|目标|复制到目标位置的项|复制到目标位置的项|  
|按住 shift + 拖动|源|删除对原始项的引用|从原始位置中删除项|  
|按住 shift + 拖动|结果|**DROPEFFECT_ 移动**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|**DROPEFFECT_ 移动**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|  
|按住 ctrl 键 + 拖动|操作|复制|复制|  
|按住 ctrl 键 + 拖动|目标|复制到目标位置的项|复制到目标位置的项|  
|按住 ctrl 键 + 拖动|源|保留对原始项的引用|保留对原始项的引用|  
|按住 ctrl 键 + 拖动|结果|**DROPEFFECT_ 副本**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|**DROPEFFECT_ 副本**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|  
|Ctrl + Shift + 拖动||不停机|不停机|  
|剪切/粘贴|操作|移动|移动|  
|剪切/粘贴|目标|复制到目标位置的项|复制到目标位置的项|  
|剪切/粘贴|源|删除对原始项的引用|从原始位置中删除项|  
|剪切/粘贴|结果|项目仍保留在存储中的原始位置|从存储中的原始位置中删除项目|  
|复制/粘贴|操作|复制|复制|  
|复制/粘贴|目标|将引用添加到原始项目|复制到目标位置的项|  
|复制/粘贴|源|保留原始项目|保留原始项目|  
|复制/粘贴|结果|项目仍保留在存储中的原始位置|项保留在原始位置单元存储|  
  
#### <a name="mixed-target-projects"></a>多重目标项目  
 下表总结了，应根据多重目标项目的情况下按下的源项和修改键特性的拖放 （以及剪切/复制/粘贴） 操作︰  
  
|||源项︰ 引用/链接|源项︰ 物理项目或文件系统 (CF_HDROP)|  
|-|-|----------------------------------|-------------------------------------------------------------|  
|没有修饰符|操作|移动|移动|  
|没有修饰符|目标|将引用添加到原始项目|复制到目标位置的项|  
|没有修饰符|源|删除对原始项的引用|删除对原始项的引用|  
|没有修饰符|结果|**DROPEFFECT_ 移动**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|**DROPEFFECT_ 移动**作为操作返回**:: Drop**和从存储中的原始位置中删除项目|  
|按住 shift + 拖动|操作|移动|移动|  
|按住 shift + 拖动|目标|将引用添加到原始项目|复制到目标位置的项|  
|按住 shift + 拖动|源|删除对原始项的引用|从原始位置中删除项|  
|按住 shift + 拖动|结果|**DROPEFFECT_ 移动**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|**DROPEFFECT_ 移动**作为操作返回**:: Drop**和从存储中的原始位置中删除项目|  
|按住 ctrl 键 + 拖动|操作|复制|复制|  
|按住 ctrl 键 + 拖动|目标|将引用添加到原始项目|复制到目标位置的项|  
|按住 ctrl 键 + 拖动|源|保留对原始项的引用|保留原始项目|  
|按住 ctrl 键 + 拖动|结果|**DROPEFFECT_ 副本**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|**DROPEFFECT_ 副本**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|  
|Ctrl + Shift + 拖动|操作|链接|链接|  
|Ctrl + Shift + 拖动|目标|将引用添加到原始项目|将引用添加到原始的源项|  
|Ctrl + Shift + 拖动|源|保留对原始项的引用|保留原始项目|  
|Ctrl + Shift + 拖动|结果|**DROPEFFECT_ 链接**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|**DROPEFFECT_ 链接**作为操作返回**:: Drop**和项目仍保留在存储中的原始位置|  
|剪切/粘贴|操作|移动|移动|  
|剪切/粘贴|目标|复制到目标位置的项|复制到目标位置的项|  
|剪切/粘贴|源|删除对原始项的引用|从原始位置中删除项|  
|剪切/粘贴|结果|项目仍保留在存储中的原始位置|从存储中的原始位置中删除项目|  
|复制/粘贴|操作|复制|复制|  
|复制/粘贴|目标|将引用添加到原始项目|复制到目标位置的项|  
|复制/粘贴|源|保留原始项目|保留原始项目|  
|复制/粘贴|结果|项目仍保留在存储中的原始位置|项目仍保留在存储中的原始位置|  
  
 这些详细信息应纳入考虑范围，实现在拖动时**解决方案资源管理器**:  
  
-   多个选择方案的设计。  
  
-   在目标项目的文件名 （完整路径） 必须是唯一或不应允许拖放。  
  
-   文件夹名称必须是唯一 （不区分大小写） 将被丢弃 — 它们级别。  
  
-   有拖动 （不在上述方案中提及） 次是打开还是关闭的文件之间的行为差异。  
  
-   顶级文件行为略有不同文件夹中的文件。  
  
 另一个问题需要注意的是如何处理具有打开的设计器或编辑器项上的移动操作。 预期的行为是，如下所示 （适用于所有项目类型）︰  
  
1.  如果打开编辑器/设计器不具有任何未保存的更改，然后编辑器/设计器窗口中应以无提示方式关闭。  
  
2.  如果打开编辑器/设计器没有未保存的更改，拖动源应等待下拉以发生然后要求用户在打开的文档具有类似于以下的提示窗口在关闭之前保存未提交的更改︰  
  
    ```  
    ==========================================================   
         One or more open documents have unsaved changes.  
    Do you want to save uncommitted changes before proceeding?   
                      [Yes]  [No]  [Cancel]   
    ==========================================================  
    ```  
  
 这使用户可以在目标进行其副本之前保存正在进行的工作。 一个新方法**IVsHierarchyDropDataSource2::OnBeforeDropNotify**增添了启用此处理。  
  
 目标然后将按原样存储区中复制项的状态 (不包括在编辑器中未保存的更改，如果用户选择**否**)。 目标已完成其复制后 (在**IVsHierarchyDropDataSource::Drop**)，源有机会在完成移动操作的删除部分 (在**IVsHierarchyDropDataSource::OnDropNotify**)。  
  
 未保存的更改与任何编辑器应保持打开状态。 对于未保存的更改与这些文档，这意味着将执行移动操作的复制部分，但将中止删除部分。 当用户选择多个选择方案中**否**，未保存的更改与这些文档不应关闭或删除，但您应该关闭并删除那些没有未保存的更改。
