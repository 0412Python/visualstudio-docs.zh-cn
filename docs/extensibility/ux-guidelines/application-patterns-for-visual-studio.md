---
title: "Visual Studio 的应用程序模式 |Microsoft 文档"
ms.custom: 
ms.date: 04/26/2017
ms.reviewer: 
ms.suite: 
ms.technology:
- vs-ide-sdk
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
caps.latest.revision: 7
ms.author: gregvanl
manager: ghogen
translation.priority.mt:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: Machine Translation
ms.sourcegitcommit: 9524ecc3cadef58821fba857de8e82e59eea9b43
ms.openlocfilehash: 7c2612cb537a6f3197cf9f99a0dc11981dfc73e1
ms.contentlocale: zh-cn
ms.lasthandoff: 05/04/2017

---
# <a name="application-patterns-for-visual-studio"></a>Visual Studio 的应用程序模式
##  <a name="BKMK_WindowInteractions"></a>窗口交互  
  
### <a name="overview"></a>概述  
在 Visual Studio 中使用的两个主窗口类型是文档编辑器和工具窗口。 少见，但可能，是大无模式对话框。 尽管这些是在外壳程序中所有无模式，其模式是完全不同。 本部分介绍文档窗口、 工具窗口和无模式对话框之间的差异。 中介绍了模式对话框模式[对话框](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)。  
  
### <a name="comparing-window-usage-patterns"></a>比较窗口使用模式  
**文档窗口**几乎始终很好地显示在文档中。 这将使文档编辑器"中心阶段"排列周围的补充工具窗口。  
  
A**工具窗口**通常显示为单独的较小窗口中折叠针对 IDE 的边缘。 这可以是可见、 隐藏或自动隐藏。 但是，有时工具窗口显示在文档井中，通过取消选中**窗口/停靠**窗口上的属性。 这会导致更多的实际空间，但另一个常见设计决策︰ 尝试将集成到 Visual Studio，你必须决定是否应显示你的功能，工具窗口或文档窗口。  
  
**无模式对话框**我们建议您不要在 Visual Studio 中。 最无模式对话框，根据定义，浮动工具窗口，并应通过这种方式实现。 在其中停靠的 shell 侧正常工具窗口的大小会极大地限制的情况下允许无模式对话框。 它们还允许在用户将可能将对话框移动到辅助监视器的情况下。  
  
考虑仔细有关哪种容器类型需要。 UI 设计的常见使用情况模式需要考虑以下几点下表中。  
  
||文档窗口|工具窗口|无模式对话框|  
|-|---------------------|-----------------|---------------------|  
| **位置** | 始终置于文档的很好地和不停靠在 IDE 的边缘周围。 它可以"请求"以使它浮动单独从主外壳程序。 | 通常在 IDE 的边缘停靠选项卡上，但可以是自定义以浮点值、 自动隐藏 （取消驻留），或也停靠在文档中。|独立于 IDE 的大型浮动窗口。 |  
| **提交模型** | *延迟的提交*<br /><br /> 若要将数据保存在文档中，用户必须发出**文件&gt;保存**，**另存为**，或**保存所有**命令。 文档窗口具有它正在"更新"中的数据的概念，然后提交到一次保存命令。 当关闭文档窗口，则将保存到磁盘所有内容或者将其丢失。 | *立即提交*<br /><br /> 没有任何保存模型。 对于检查器工具窗口可帮助你编辑文件，必须先在活动编辑器或设计器中，打开文件和编辑器或设计器拥有保存。 | *延迟或立即提交*<br /><br /> 大多数情况下，大型的无模式对话框需要执行操作，以提交更改，并允许一个"取消"操作，从而回滚在对话会话中进行了任何更改。  工具窗口始终具有立即提交模型，这将从工具窗口的无模式对话框区分开来。 |  
| **可见性** | *打开/创建 （文件） 并关闭*<br /><br /> 打开文档窗口是通过打开现有文档或使用模板创建新文档。 没有任何"打开\<特定编辑器 >"命令。 | *隐藏和显示*<br /><br /> 单实例工具窗口可以显示或隐藏。 内容和工具窗口中的省保留是否视图中或隐藏。 多实例工具窗口可以被关闭，以及隐藏。 当关闭多实例工具窗口时，内容和工具窗口中的状态将被丢弃。 | *从命令启动*<br /><br /> 从基于任务的命令启动对话框。 |  
| **实例** | *多实例*<br /><br /> 当某些编辑器还允许相同的文件可在多个编辑器中打开时，可以在同一时间和编辑不同的文件，打开多个编辑器 (使用**窗口&gt;新窗口**命令)。<br /><br /> 在同一时间 （项目设计器），单个编辑器可能正在编辑一个或多个文件。 | *单-或多-instance*<br /><br /> 内容发生更改以反映上下文 （如所示属性浏览器） 或将焦点/上下文推送到其他窗口 （解决方案资源管理器中的任务列表）。<br /><br /> 如果没有人信服的理由不到，单实例和多实例工具窗口应与活动文档窗口相关联。 | *单实例* |  
| **示例** | **文本编辑器**，如代码编辑器<br /><br /> **设计图面**，如窗体设计器或建模图面<br /><br /> **控制布局类似于对话框**，如清单设计器 | **解决方案资源管理器**提供解决方案和解决方案中包含的项目<br /><br /> **服务器资源管理器**提供用户选择在窗口中打开的服务器和数据连接的分层视图。 从数据库层次结构，如查询中，打开对象打开文档窗口，并允许用户编辑查询。<br /><br /> **属性浏览器**显示在文档窗口或另一个工具窗口中的所选对象的属性。 属性在层次结构的网格视图中或复杂的类似于对话框的控件中已提供，并允许用户设置这些属性的值。 | |  
  
##  <a name="BKMK_ToolWindows"></a>工具窗口  
  
### <a name="overview"></a>概述  
工具窗口支持文档窗口中的用户的工作。 它们可以用于显示表示 Visual Studio 提供，并可以操作的基本根对象的层次结构。  
  
在考虑将新的工具窗口在 IDE 中，作者应︰  
  
-   使用相应任务的现有工具窗口，并创建新的具有类似功能。 如果他们提供明显不同的"工具"或功能，不能将其集成到类似窗口，或通过到透视中心启用现有的窗口，则只应创建新工具窗口。  
  
-   使用标准命令栏中，如果需要在工具窗口的顶部。  
  
-   是与模式中已有的其他工具窗口的控件演示文稿和键盘导航一致。  
  
-   是与其他工具窗口中的控件演示文稿一致。  
  
-   使文档特定工具窗口自动可见尽可能，以便它们显示只有在激活的父文档时。  
  
-   请确保其窗口内容通过键盘 （支持箭头键） 可导航。  
  
#### <a name="tool-window-states"></a>工具窗口状态  
Visual Studio 工具窗口具有不同的状态，其中一些用户激活 （如自动隐藏功能）。 其他状态，如自动可见，允许以正确的上下文中显示和隐藏时不需要的工具窗口。 总共有五个工具窗口状态。  
  
-   **停靠/固定**工具窗口可以附加到文档区域四边的任何。 图钉图标将显示在工具窗口标题栏中。 工具窗口可边缘的 shell 和其他工具窗口，水平或垂直停靠，而且还可能链接到选项卡。  
  
-   **自动隐藏**工具窗口是不驻留。 不可见，让文档区域的边缘在空闲时 （使用该工具窗口和其图标的名称） 的选项卡可以滑动窗口。 当用户悬停在选项卡时，工具窗口滑出。  
  
-   **自动可见**UI 中，如编辑器的另一条启动或获得焦点时自动显示工具窗口。  
  
-   **浮点**工具窗口将鼠标悬停在 IDE 之外。 这可用于多监视器配置。  
  
-   **选项卡式的文档**工具窗口可以停靠在文档中也。 这可用于大工具窗口，如对象浏览器，需要更多房地产超出与帧边缘停靠允许。  
  
![Visual Studio 中的工具窗口状态](~/extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702-01_ToolWindowStates")<br />Visual Studio 中的“工具”窗口状态
  
#### <a name="single-instance-and-multi-instance"></a>单实例和多实例  
工具窗口是单实例或多实例。 多实例工具窗口可能不时，某些单实例工具窗口可能有与活动文档窗口中，相关联。 多实例工具窗口响应**窗口&gt;新窗口**命令通过创建窗口的新实例。 下图阐释了工具窗口的窗口实例处于活动状态时启用新窗口命令︰  
  
![工具窗口中，这样新建窗口命令窗口的实例时处于活动状态](~/extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702-02_ToolWindowEnablingCommand")<br />工具窗口中，这样新建窗口命令窗口的实例时处于活动状态  
  
可以隐藏或显示，而多实例工具窗口可以被关闭，以及隐藏单实例工具窗口。 所有工具窗口可以都停靠，选项卡链接、 浮动或设置为多文档界面 (MDI) 子窗口 （类似于文档窗口）。 所有工具窗口应都响应窗口菜单中的相应的窗口管理命令︰  
  
![在 Visual Studio 窗口菜单中的窗口管理命令](~/extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702-03_WindowManagementControls")<br />在 Visual Studio 窗口菜单中的窗口管理命令
  
#### <a name="document-specific-tool-windows"></a>特定于文档的工具窗口  
某些工具窗口用于更改基于给定类型的文档。 这些窗口不断进行更新，以反映适用于 IDE 中的活动文档窗口的功能。  
  
其内容更改以反映所选的编辑器的工具窗口的示例包括工具箱中和文档大纲。 当编辑器具有不提供到窗口的上下文的焦点时，这些窗口将显示一个水印。  
  
#### <a name="navigable-list-tool-windows"></a>可导航列表工具窗口  
某些工具窗口显示的用户可以与交互可导航的项的列表。 在此类型的窗口中，应始终有在列表中，当前项的反馈即使窗口处于非活动状态。 列表应响应**GoToNextLocation**和**GoToPrevLocation**命令也可更改窗口中的当前选定的项  
  
可导航列表工具窗口的示例包括解决方案资源管理器和查找结果窗口。  
  
### <a name="tool-window-types"></a>工具窗口类型  
  
#### <a name="common-tool-windows-and-their-functions"></a>常用的工具窗口和其函数

**层次结构工具窗口**
| 工具窗口 | 函数 | 
| --- | --- | 
| “解决方案资源管理器” | 层次结构树中显示的文档列表包含在项目、 杂项文件和解决方案项。 项目中的项的显示由拥有该项目类型 （例如，基于引用的、 基于目录或混合模式类型） 的包定义。 | 
| 类视图 | 类和文档，文件本身的独立的工作集中各个元素的分层树。 | 
| 服务器资源管理器 | 显示解决方案中的所有服务器和数据连接的分层树。 | 
| 文档大纲 | 活动文档的层次结构。 | 

**网格工具窗口**
| 工具窗口 | 函数 | 
| --- | --- | 
| 属性 | 一个网格，其中显示所选对象，以及值选取器，若要编辑这些属性的属性的列表。 | 
| 任务列表 | 一个网格，允许用户创建/编辑/删除任务和批注。 | 

**内容的工具窗口**
| 工具窗口 | 函数 | 
| --- | --- | 
| 帮助 | 一个窗口，允许用户访问于各种不同方法获取帮助，从"我如何？" MSDN 论坛视频。 | 
| 动态帮助 | 工具窗口，其中显示链接到帮助主题适用于当前的选择。 | 
| 对象浏览器 | 在左的窗格和对象的属性层次结构对象组件和右侧列中的方法的列表两列框架集。 | 

**对话框工具窗口**
| 工具窗口 | 函数 | 
| --- | --- | 
| 查找 | 一个对话框，允许用户查找或查找和替换在解决方案中的各种文件中。 |
| 高级的查找 | 一个对话框，允许用户查找或查找和替换在解决方案中的各种文件中。 | 

**其他工具窗口**
| 工具窗口 | 函数 | 
| --- | --- | 
| 工具箱 | 用于存储将放置到设计图面，为所有设计器提供一致的拖动源的元素的工具窗口。 |
| 起始页 | 用户的门户到 Visual Studio 中，有权访问的开发人员新闻、 Visual Studio 帮助和最近的项目的源。 用户还可以通过复制中的 StartPage.xaml 文件创建自定义起始页"Common7\IDE\StartPages\" Visual Studio 中 Visual Studio 文档目录，然后手动编辑 XAML 或在 Visual Studio 或其他代码编辑器中打开它的 StartPages 文件夹的 program files 目录。 | 

**调试器工具窗口**
| 工具窗口 | 函数 | 
| --- | --- |
| 自动 ||  
| 即时 ||  
| 输出 | 只要你有文本事件或状态来声明，可以使用输出窗口。 |  
| 内存 ||  
| 断点 ||  
| 正在运行 ||  
| 文档 ||  
| 调用堆栈 ||  
| 局部变量 ||  
| 监视点 ||  
| 反汇编 ||  
| 寄存器 ||  
| 线程 ||  
  
##  <a name="BKMK_DocumentEditorConventions"></a>文档编辑器约定  
  
### <a name="document-interactions"></a>文档交互  
"文档也"是在 IDE 中的最大空间，其中用户通常一直致力于他们注意若要完成其任务，由补充工具窗口协助。 文档编辑器表示的基本用户打开和保存 Visual Studio 中的工作单元。 它们仍然保留了所选内容与解决方案资源管理器或其他活动的层次结构窗口相关联的明确识别。 用户应该能够指向一个这些层次结构窗口和解决方案、 项目或 Visual Studio 包所提供的另一个根对象知道包含该文档和及其之间的关系。  
  
文档编辑需要一致的用户体验。 若要允许用户以专注于手头的任务而不是在窗口管理和查找命令上，选择最适合用于编辑该文档类型的用户任务的文档视图策略。  
  
#### <a name="common-interactions-for-the-document-well"></a>文档井中的常见的交互  
  
-   维护中常见的一致交互模型**新文件**和**打开的文件**体验。  
  
-   文档窗口打开时，请更新相关的 windows 和菜单中的相关的功能。  
  
-   菜单命令适当地集成到了类似的常见菜单**编辑**，**格式**，和**视图**菜单。 如果大量的专用命令都不可用，则可以创建新菜单。 仅当该文档具有焦点时，则应可以看到此新菜单。  
  
-   可能在编辑器的顶部放置嵌入式工具栏。 这是使其显示在编辑器外的单独工具栏更可取。  
  
-   始终保持在解决方案资源管理器或类似活动中的选项层次结构窗口。  
  
-   双击解决方案资源管理器中的文档应该执行相同的操作**打开**。  
  
-   如果可以在文档类型上使用多个编辑器，用户应该能够重写或重置给定的文档类型使用的默认操作**打开**对话框中，通过右键单击文件并选择**打开**从快捷菜单。  
  
-   也不生成文档中的向导。  
  
### <a name="user-expectations-for-specific-document-types"></a>对用户的预期要求特定的文档类型  
有多种不同的基本类型的文档编辑器，并且每个都有一组交互与同一类型的其他人相一致。  
  
-   **基于文本的编辑器︰**代码编辑器、 日志文件  
  
-   **设计图面︰** WPF 窗体设计器中，Windows 窗体  
  
-   **对话框样式编辑器︰**清单设计器中，项目属性  
  
-   **模型设计器︰**工作流设计器、 codemap、 体系结构关系图、 进度  
  
也有很好地使用文档的多个非编辑器类型。 尽管它们不编辑文档本身，他们需要按照文档窗口的标准交互操作。  
  
-   **报表︰** IntelliTrace 报告，HYPER-V 报告，探查器报告  
  
-   **仪表板︰**诊断中心  
  
#### <a name="text-based-editors"></a>基于文本的编辑器  
  
-   文档参与预览选项卡模型，从而使预览文档，而无需打开它。  
  
-   可以在助理工具窗口，如文档大纲内表示文档的结构。  
  
-   与其他代码编辑器的 IntelliSense （如果适用） 行为一致。  
  
-   弹出窗口或辅助 UI 的现有类似的用户界面，例如 CodeLens 遵循类似的样式和模式。  
  
-   在文档顶部的信息栏控件中或在状态栏中，系统将提供有关文档状态消息。  
  
-   用户必须能够自定义的字体和颜色使用外观**工具 > 选项**页上，共享的字体和颜色页或一个特定的编辑器。  
  
#### <a name="design-surfaces"></a>设计图面  
  
-   空的设计器应具有一个水印，该值指示如何开始的图面上。  
  
-   视图切换机制将遵循现有的模式，如双击以打开代码编辑器中或允许与这两个窗格的交互的文档窗口中的选项卡。  
  
-   应该通过工具箱中，完成将元素添加到设计图面，除非需要高度特定工具窗口。  
  
-   面上将按照一致的选择模型。  
  
-   嵌入的工具栏包含特定于文档的命令仅、 不是公共命令，如**保存**。  
  
#### <a name="dialog-style-editors"></a>对话框样式编辑器  
  
-   控件布局应遵循正常对话框布局约定。  
  
-   在编辑器中的选项卡不应与文档选项卡的外观，它们应匹配的两个允许内部选项卡样式之一。  
  
-   用户必须能够与使用键盘仅; 这些控件交互通过使用标准的助记键激活编辑器并按 tab 键通过控件或的任意一个。  
  
-   设计器应使用的常见保存模型。 虽然其他按钮可能合适，应该表面上看，放置没有总体保存或提交按钮。  
  
#### <a name="model-designers"></a>模型设计器  
  
-   空的设计器应具有一个水印，该值指示如何开始的图面上。  
  
-   将元素添加到设计图面时，应该通过工具箱来完成。  
  
-   面上将按照一致的选择模型。  
  
-   嵌入的工具栏包含特定于文档的命令仅、 不是公共命令，如**保存**。  
  
-   图例可以出现在图面，指示或成为水印。  
  
-   用户必须能够自定义使用的字体/颜色外观**工具 > 选项**页上，共享的字体和颜色页或一个特定的编辑器。  
  
#### <a name="reports"></a>报表  
  
-   报表是通常只信息和不参与保存模型。 但是，它们可能包括如链接到其他相关信息或展开和折叠的部分的交互。  
  
-   在图面上的大部分命令应为超链接，不按钮。  
  
-   布局应包含标头，并按照标准报表布局。  
  
#### <a name="dashboards"></a>面板  
  
-   仪表板无交互模型本身，但作为一种方式来提供各种其他工具。  
  
-   它们不参与保存模型。  
  
-   用户必须能够与使用键盘、 只可通过激活编辑器并按 tab 键浏览控件或通过使用标准的助记键的控件进行交互。  
  
##  <a name="BKMK_Dialogs"></a>对话框  
  
### <a name="introduction"></a>介绍  
Visual Studio 中的对话框通常应支持一个离散的用户的工作单位，然后关闭。  
  
如果你确定你需要一个对话框，可以选择三种，按优先顺序︰  
  
1.  将你的功能集成到 Visual Studio 中的共享对话框之一。  
  
2.  创建你自己的对话框使用在现有的类似对话框中找到的模式。  
  
3.  创建一个新的对话框、 以下交互和布局准则。  
  
本部分介绍如何选择 Visual Studio 工作流中的正确对话框模式和对话框设计的常见约定。  
  
### <a name="themes"></a>主题  
Visual Studio 中的对话框，请执行两种基本的样式之一︰  
  
#### <a name="standard-unthemed"></a>标准 (unthemed)  
对话框的大多数标准实用程序对话框并且应将 unthemed。 不要重新创建模板公共控件，或尝试创建样式化"现代"按钮或控件。 控件和 chrome 外观按照[适用于对话框的标准 Windows 桌面交互准则](https://msdn.microsoft.com/en-us/library/windows/desktop/dn742499\(v=vs.85\).aspx)。  
  
#### <a name="themed"></a>主题  
Specialty"签名"对话框可能主题。 主题对话框都具有独特的外观，还有一些与样式关联的特殊交互模式。 主题对话中仅当满足这些要求︰  
  
-   对话框是一种通用的体验，将看到并使用通常或多个用户 (例如，**新项目**对话框。  
  
-   包含突出显示的产品品牌元素的对话框 (例如，**帐户设置**对话框)。  
  
-   对话框显示为包括其他主题的对话框的较大流的组成部分 (例如，**添加连接的服务**对话框)。  
  
-   对话框是体验的扮演着关键角色提升或区分产品版本中的重要组成部分。  
  
在创建主题对话框时，使用适当的环境颜色，并遵循正确的布局和交互模式。 (请参阅[for Visual Studio 布局](../../extensibility/ux-guidelines/layout-for-visual-studio.md)。)  
  
### <a name="dialog-design"></a>对话框设计  
设计良好的对话框需要考虑下列元素︰  
  
-   支持用户任务  
  
-   对话框文本样式、 语言和术语  
  
-   控件选择和 UI 约定  
  
-   可视布局规范和控件的对齐方式  
  
-   键盘访问  
  
#### <a name="content-organization"></a>内容的组织  
请考虑这些基本类型的对话框之间的差异︰  
  
-   [简单对话框](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs)存在单个模式窗口中的控件。 演示文稿可能包含变体的复杂控件模式，包括字段选取器或图标栏。  
  
-   [分层对话框](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs)使用一段单独的 UI 包含的控件的多个组时要充分利用屏幕的实际空间。 对话框的分组"位于"通过选项卡控件、 导航列表控件或按钮，以便用户可以选择分组以查看在任何给定时刻。  
  
-   [向导](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards)可用于将定向逻辑的步骤来完成任务序列通过用户。 选择一系列顺序面板，有时引入了不同的工作流 （"分支"） 依赖于在上一面板中所做的选择中提供。  
  
####  <a name="BKMK_SimpleDialogs"></a>简单对话框  
简单对话框是一个模式窗口中的控件的演示。 此演示文稿可能包含变体的复杂控件模式，如域选取器。 有关简单对话框，请遵循标准的常规布局，以及所需的复杂控件分组任何特定布局。
  
![> 创建强名称密钥是一个简单的对话框在 Visual Studio 中的一个示例。](~/extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704-01_CreateStrongNameKey")<br />创建强名称密钥是一个简单的对话框在 Visual Studio 中的一个示例。
  
####  <a name="BKMK_LayeredDialogs"></a>分层的对话框  
分层的对话框包括选项卡、 仪表板和嵌入的树。 它们用于最大化房地产有多个组的一段单独的 UI 中提供的控件时。 分组进行分层，以便用户可以选择以在任何时候查看哪些分组。  
  
在最简单的情况下，用于分组之间进行切换的机制是选项卡控件。 有多种可选方案。 请参阅优先级和有关如何选择最合适的样式的分层。  
  
**工具&gt;选项**对话框是分层对话框使用嵌入的树的示例︰  
  
![工具 > 选项是分层对话框在 Visual Studio 中的一个示例。](~/extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704-02_ToolsOptions")<br />工具 > 选项是分层对话框在 Visual Studio 中的一个示例。
  
####  <a name="BKMK_Wizards"></a>向导  
向导可用于将用户通过一系列逻辑步骤定向中的任务完成。 选择一系列提供连续面板中，用户必须继续完成然后再继续到下的每个步骤。 一旦足够的默认值为可用，**完成**按钮处于启用状态。  
  
 模式向导用于任务的︰  
  
-   包含分支，具体取决于用户选择其中提供不同的路径  
  
-   包含的步骤，其中后续步骤依赖于来自前面的步骤的用户输入之间的依赖关系  
  
-   足够复杂 UI 应该用于说明提供的选项以及每个步骤中的可能结果  
  
-   是事务性的这需要一组的步骤的任何更改在提交之前完成整个  
  
### <a name="common-conventions"></a>常见约定  
若要实现最佳设计和功能与你的对话框，并遵照这些约定对话框大小、 位置、 标准、 控制配置和对齐方式、 UI 文本、 标题栏、 控件按钮和访问密钥。  
  
有关特定布局的指南，请参阅[for Visual Studio 布局](../../extensibility/ux-guidelines/layout-for-visual-studio.md)。  
  
#### <a name="size"></a>大小  
对话框应适合较小的 1024 x 768 屏幕分辨率和初始对话框大小不应超过 900 x 700 像素为单位。 对话框可能可调整大小，但它不是一项要求。  
  
有两个建议可调整大小的对话框︰  
  
1.  最小大小被定义为将针对控件进行优化的对话框没有剪辑，设置并调整以适应合理本地化增长。  
  
2.  用户缩放大小仍然存在于会话之间。 例如，如果用户可以扩展至 150%一个对话框，则后续启动的对话框将显示在 150%。  
  
#### <a name="position"></a>位置  
对话框必须出现在首次启动 IDE 内居中。 无法调整大小的对话框的最后一个位置不需要保持不变，因此它们将会显示在后续启动上居中。 

可调整大小的对话框，应在后续启动上保留大小。 可调整大小的模式对话框，位置不需要保留。 显示在 IDE 中居中它们可防止显示在不可预知的或不可用的位置中，当用户的显示配置发生更改时对话框的可能性。 

可重新定位的无模式对话框，应用户的位置保留在后续启动，这是因为对话框可能用作频繁的大型工作流的组成部分。  
  
当对话框必须生成其他对话框时，最顶层对话框应级联向右和向下从父以便它的明显到它们已导航到新位置的用户。  
  
#### <a name="modality"></a>模式  
正在模式意味着用户所需完成或在继续之前取消对话框。 由于模式对话框阻止与环境的其他部分进行交互用户，你的功能的任务流应尽可能尽量少使用它们。 需要模式操作时，Visual Studio 将具有大量你可以将各种功能集成到共享对话框。 如果必须创建一个新的对话框，遵循现有的对话框的交互模式具有类似功能。  
  
当用户需要同时执行两个活动时，如**查找**和**替换**时编写新代码，该对话框应为无模式，以便用户可以轻松地它们之间切换。 Visual Studio 通常使用此类型的编辑器支持链接的任务的工具窗口。  
  
#### <a name="control-configuration"></a>控制配置  
是与完成同样的操作，在 Visual Studio 中的现有控件配置一致。  
  
#### <a name="title-bars"></a>标题栏  
  
-   中的标题栏的文本必须反映启动它命令的名称。  
  
-   应在对话框的标题栏中使用无图标。 系统要求一个位置的情况下，使用 Visual Studio 徽标。  
  
-   对话框不应具有最小化或最大化按钮。  
  
-   已弃用的标题栏中的帮助按钮。 不要将它们添加到新的对话框。 当它们存在时，他们应启动在概念上与任务相关的帮助主题。  
  
 ![Visual Studio 对话框中的标题栏的原则规范](~/extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704-03_TitleBarSpecs")<br />Visual Studio 对话框中的标题栏的原则规范
  
#### <a name="control-buttons"></a>控件按钮  
一般情况下，**确定**，**取消**，和**帮助**按钮应在对话框右下角中水平排列。 如果对话框有表示与控件按钮 visual 混淆的对话框底部的其他几个按钮，则允许备用垂直堆栈。  
  
![可接受配置 Visual Studio 对话框中的控件按钮](~/extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704-04_ControlButtonConfig")<br />可接受配置 Visual Studio 对话框中的控件按钮
  
对话框必须包括默认控件按钮。 若要确定最佳的命令，以便使用作为默认值，请选择从以下选项 （按优先级顺序列出）︰  
  
-   选择的安全和最安全命令作为默认值。 这意味着选择最有可能，以防止数据丢失并避免意外的系统访问权限的命令。  
  
-   如果数据丢失和安全不因素，然后选择基于方便的默认命令。 当对话框支持频繁或重复的任务时，包括默认值为最可能的命令将提高用户的工作流。  
  
避免选择的默认命令的永久破坏性操作。 如果存在此类命令，则更安全的命令为默认值改为选择。  
  
#### <a name="access-keys"></a>访问密钥  
不使用访问密钥**确定**，**取消**，或**帮助**按钮。 默认情况下，这些按钮映射到键盘快捷方式︰  
  
| 按钮名称 | 键盘快捷方式 |  
| --- | --- |  
| 确定 | Enter |  
| 取消 | Esc |  
| 帮助 | F1 |  
  
#### <a name="imagery"></a>图像  
在对话框中尽量少使用映像。 请勿使用大图标对话框中仅使用了空间。 使用映像才会传达给用户，例如警告图标或状态动画消息的重要组成部分。  
  
###  <a name="BKMK_PrioritizingAndLayering"></a>确定需求优先顺序和分层  
  
#### <a name="prioritizing-your-ui"></a>优先处理你的 UI  
它可能需要某些用户界面元素置于前端，更高级的行为和到对话框选项 （包括晦涩命令）。 通过使腾出空间供它，并使其可见的文本标签 UI 在默认情况下显示的对话框时，可在前端中将常用的功能。  
  
#### <a name="layering-your-ui"></a>分层你的 UI  
如果你确定对话框是必需的但你想要向用户显示相关的功能远不止一个简单的对话框中可以显示的内容，则你需要层你的 UI。 Visual Studio 将使用最常见的分层方法是选项卡和走廊或仪表板。 在某些情况下，可以展开和折叠的区域可能正合适。 在 Visual Studio 中通常不建议自适应用户界面。  
  
有一些优点和缺点的分层通过类似于选项卡上的控件的 UI 的不同方法。 查看下面以确保您选择适合于你的情况的分层方法的列表。  
  
##### <a name="tabbing"></a>Tab 键次序  
  
| 切换机制 | 优点和相应的使用 | 缺点和不恰当地使用 |  
| --- | --- | --- |  
| Tab 控件 | 进行逻辑分组到相关设置的对话框页面<br /><br />用于少于五个 （或对话框调整在一行中的选项卡的数目） 对话框中相关控件的页<br /><br />选项卡标签必须是短︰ 可以轻松地识别的内容的一个或两个单词<br /><br />常见的系统对话框样式<br /><br />示例︰**文件资源管理器&gt;项属性** | 就很难做出短的描述性标签<br /><br />通常不能超越一个对话框中的五个选项卡<br /><br />如果你有一个行 （使用备用分层技术） 的过多选项卡不适合<br /><br />不可扩展 |  
| 边栏导航 | 可以容纳更多的类别选项卡比的简单切换设备<br /><br />类别 （无层次结构） 的简单列表<br /><br />可扩展<br /><br />示例︰**自定义...&gt;添加命令** | 使用的水平空间少于三个组是否不好<br /><br />任务可能是更好地适合于下拉列表 |  
| 树控件 | 允许不受限制的类别<br /><br />允许的分组和/或类别的层次结构<br /><br />可扩展<br /><br />示例︰**工具&gt;选项** | 很大程度嵌套层次结构可能会导致过多的水平滚动<br /><br />Visual Studio 具有过度使用了树视图 |  
| 向导 | 引导用户完成基于任务的顺序步骤与完成任务的帮助︰ 向导表示的高级任务，并且单个面板表示完成整个任务所需的子任务<br /><br />当跨 Ui 边界，作为时用户那些原本要使用多个编辑器和工具窗口完成任务的任务时有用<br /><br />当此任务需要分支时有用<br /><br />当任务中包含步骤之间的依赖关系时有用<br /><br />当使用一个决策分叉的多个类似任务可以显示在一个对话框，以减少的数量不同类似对话框时有用 | 不适合于任何不需要的顺序工作流的任务<br /><br />用户可以成为失控和混淆具有太多步骤的向导<br /><br />向导具有本质上被有限的屏幕的实际空间 |  
  
##### <a name="hallways-or-dashboards"></a>走廊或仪表板  
走廊和仪表板是对话框或用作启动指向其他对话框和窗口的面板。 设计良好的"相邻"立即显示仅最常见的选项、 命令和设置，使用户能够轻松地完成常见任务。 像实际走廊提供入口访问它们之后聊天室，此处不太常见 UI 收集到单独"聊天室"（通常是其他对话框） 的可以从主走廊访问的相关功能。  
  
或者，一个用户界面，而不是重构的不太常见功能分为不同的位置，则只需一个仪表板提供单个集合中的所有可用的功能。  
  
![用于公开其他 UI 在 Outlook 中的过道概念](~/extensibility/ux-guidelines/media/0704-08_hallway.png "0704-08_Hallway")<br />用于公开其他 UI 在 Outlook 中的过道概念
  
##### <a name="adaptive-ui"></a>自适应用户界面  
显示或隐藏用户界面基于使用情况或用户的自助报告的体验是另一种同时隐藏了其他部分中提供必要的 UI。 这不是建议在 Visual Studio 中，用于确定何时显示或隐藏 UI 算法可能会很棘手，以及规则将始终为错误的情况下的某一集。  
  
##  <a name="BKMK_Projects"></a>项目  
  
### <a name="projects-in-the-solution-explorer"></a>在解决方案资源管理器的项目  
大多数项目被归类为基于引用的、 基于目录或混合。 在解决方案资源管理器中同时支持所有三种类型的项目。 使用项目中的用户体验的根在此窗口内发生。 尽管所不同的项目节点的引用、 目录或混合模式类型的项目，但是没有拆分成特定于项目的用户模式之前应该作为起始点应用常见的交互模式。  
  
项目应始终︰  
  
-   支持的功能添加项目文件夹来组织项目内容  
  
-   维护一致的模型为项目暂留  
  
项目还应该维护一致的交互模型︰  
  
-   删除项目项  
  
-   保存文档  
  
-   项目属性编辑  
  
-   编辑另一种视图中的项目  
  
-   拖放操作  
  
### <a name="drag-and-drop-interaction-model"></a>拖放交互模型  
项目通常分类本身作为基于引用的 （能够保持对存储中的项目项的唯一引用），基于目录 （能够以物理方式保留唯一项目项存储在项目的层次结构），或混合 （能够保存引用或物理项）。 IDE 可容纳所有三种类型的项目中同时**解决方案资源管理器**。  
  
从拖放的角度看，下列特性应该应用于每种类型的项目中**解决方案资源管理器**:  
  
-   **基于引用的项目︰**的要点是，将项目拖动围绕对存储中的项的引用。 当基于引用的项目可作为移动操作的源时，它应仅移除对该项目从项目的引用。 不应从硬盘实际删除的项目。 当基于引用的项目可作为移动 （或复制） 操作的目标时，它应无需进行的项的私有副本添加到原始的源项的引用。  
  
-   **基于目录的项目︰**拖放的角度来看，从项目拖动围绕物理项而不是的引用。 当一个目录基于项目充当移动操作的源时，它应结束从硬盘中删除物理项，以及从项目中将其删除。 当基于 directory 项目充当移动 （或复制） 操作的目标时，它应在其目标位置进行源项的副本。  
  
-   **混合目标项目︰**从拖放的角度来看，此类型的项目的行为取决于 （对存储中的项的引用），或者针对项本身所拖动的项的性质。 引用和物理项的正确行为是上面所述。  
  
如果没有的项目中只有一个类型**解决方案资源管理器**，则将直接拖放操作。 因为每个项目系统可定义其自己的拖放行为的功能，应遵循特定的准则 （基于 Windows 资源管理器拖放行为），以确保可预测的用户体验︰  
  
-   未修改拖动操作**解决方案资源管理器**（时 Ctrl 和 Shift 键都不按住） 应导致移动操作。  
  
-   按住 shift 并拖动操作还应导致移动操作。  
  
-   按住 Ctrl 并拖动操作应导致复制操作。  
  
-   基于引用的和混合项目系统支持到源项添加链接 （或引用） 的概念。 当这些项目都拖放操作的目标 (时**Ctrl + Shift**是否按下)，它应导致对项添加到项目的引用  
  
在基于引用的、 基于目录的和混合项目的组合，并非所有的拖放操作是合理的。 具体而言，它会产生问题，以假设允许基于 directory 的源项目和基于引用的目标项目之间移动操作，因为源目录基于项目将需要删除完成移动后的源项。 然后最终目标基于引用的项目会得到对已删除的项的引用。  
  
还有误导性，以假设允许这些类型的项目之间复制操作，因为目标基于引用的项目不应作出的源项的独立副本。 同样，Ctrl + Shift 拖动到基于目录的目标项目，从而不应允许由于基于目录的项目是无法进行持久化的引用。 在其中不支持拖放操作的情况下，IDE 应禁止下拉并向用户显示非放置光标 （下指针表中所示）。  
  
若要正确实现拖放行为，拖动源项目需要进行通信目标项目到其性质。 （例如，是基于引用或目录的？）此信息由提供的源的剪贴板格式表示。 拖动 （或剪贴板复制操作） 的源作为项目应提供或者`CF_VSREFPROJECTITEMS`或`CF_VSSTGPROJECTITEMS`分别，具体取决于项目是基于引用的或基于目录。 这两个这些格式具有相同的数据内容，这是类似于 Windows`CF_HDROP`设置的格式，但列表的字符串，而不是文件名，是双-`NULL`终止的列表`Projref`字符串 (从返回`IVsSolution::GetProjrefOfItem`或`::GetProjrefOfProject`根据需要)。  
  
放置 （或剪贴板粘贴操作） 的目标，作为项目应接受这两项`CF_VSREFPROJECTITEMS`和`CF_VSSTGPROJECTITEMS`，不过拖放操作的确切处理而异的目标项目和源项目的性质。 源项目是否它提供通过声明其性质`CF_VSREFPROJECTITEMS`或`CF_VSSTGPROJECTITEMS`。 放置目标了解自己性质，因此，具有足够的信息来决定与是否移动、 复制或应执行链接。 用户还会修改的拖放操作应执行通过按 Ctrl、 shift 键，或同时 Ctrl 和 Shift 键。 对拖放目标以正确地表明将提前在执行哪些操作很重要其`DragEnter`和`DragOver`方法。 **解决方案资源管理器**自动知道源项目和目标项目是否相同的项目。  
  
具体而言不支持 （例如，从 devenv.exe 到另一个实例） 的 Visual Studio 实例之间拖动项目项。 **解决方案资源管理器**还直接禁用这。  
  
用户应始终能够通过选择某一项，将其拖到目标位置，并观察后者以下鼠标指针显示项目被丢弃之前确定拖放操作的效果︰  
  
| 鼠标指针 | 命令 | 描述 |  
| :---: | --- | --- |  
| ![鼠标"不放下"图标](~/extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706年 01_MouseNoDrop") | 不拖放 | 不到指定位置删除项。 |  
| ![鼠标"复制"图标](~/extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706年 02_MouseCopy") | 复制 | 将项复制到目标位置。 |  
| ![鼠标"移动"图标](~/extensibility/ux-guidelines/media/0706-03_mousemove.png "0706年 03_MouseMove") | 移动 | 项将移到目标位置。 |  
| ![鼠标"添加引用"图标](~/extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706年 04_MouseAddRef") | 添加引用 | 对所选的项的引用将添加到目标位置。 |

#### <a name="reference-based-projects"></a>基于引用的项目  
 下表总结了应执行基于对于基于引用的目标项目按下的源项和修饰符键的性质的拖放 （以及剪切/复制/粘贴） 操作︰  
  
| 修饰符 | 类别 | 源项︰ 引用/链接 | 源项︰ 物理项或文件系统 (`CF_HDROP`) |  
| --- | --- | --- | --- |  
| 没有修饰符 | 操作 | 移动 | 链接 |  
| 没有修饰符 | 目标 | 将引用添加到原始项目 | 将引用添加到原始项目 |  
| 没有修饰符 | 源 | 删除对原始项目的引用 | 保留原始项目 |  
| 没有修饰符 | 结果 | `DROPEFFECT_MOVE`作为从操作返回`::Drop`并项保留在存储中的原始位置 | `DROPEFFECT_LINK`作为从操作返回`::Drop`并项保留在存储中的原始位置 |  
| 按住 shift + 拖动 | 操作 | 移动 | 不拖放 |  
| 按住 shift + 拖动 | 目标 | 将引用添加到原始项目 | 不拖放 |  
| 按住 shift + 拖动 | 源 | 删除对原始项目的引用 | 不拖放 |  
| 按住 shift + 拖动 | 结果 | `DROPEFFECT_MOVE`作为从操作返回`::Drop`并项保留在存储中的原始位置 | 不拖放 |  
| Ctrl + 拖 | 操作 | 复制 | 不拖放 |  
| Ctrl + 拖 | 目标 | 将引用添加到原始项目 | 不拖放 |  
| Ctrl + 拖 | 源 | 保留原始项目引用 | 不拖放 |  
| Ctrl + 拖 | 结果 | `DROPEFFECT_COPY`作为从操作返回`::Drop`并项保留在存储中的原始位置 | 不拖放 |  
| Ctrl + Shift + 拖 | 操作 | 链接 | 链接 |  
| Ctrl + Shift + 拖 | 目标 | 将引用添加到原始项目 | 将引用添加到原始项目 |  
| Ctrl + Shift + 拖 | 源 | 保留原始项目引用 | 保留原始项目 |  
| Ctrl + Shift + 拖 | 结果 | `DROPEFFECT_LINK`作为从操作返回`::Drop`并项保留在存储中的原始位置 | `DROPEFFECT_LINK`作为从操作返回`::Drop`并项保留在存储中的原始位置 |  
| Ctrl + Shift + 拖 | 说明 | 在 Windows 资源管理器的快捷方式拖放行为相同。 ||  
| 剪切/粘贴 | 操作 | 移动 | 链接 |  
| 剪切/粘贴 | 目标 | 将引用添加到原始项目 | 将引用添加到原始项目 |  
| 剪切/粘贴 | 源 | 保留原始项目引用|保留原始项目 |  
| 剪切/粘贴 | 结果 | 项目仍保留在存储中的原始位置 | 项目仍保留在存储中的原始位置 |  
| 复制/粘贴 | 操作 | 复制 | 链接 |  
| 复制/粘贴 | 源 | 将引用添加到原始项目 | 将引用添加到原始项目 |  
| 复制/粘贴 | 结果 | 保留原始项目引用 | 保留原始项目 |  
| 复制/粘贴 | 操作 | 项目仍保留在存储中的原始位置 | 项目仍保留在存储中的原始位置 |  
  
#### <a name="directory-based-projects"></a>基于目录的项目  
下表总结了应执行基于按下的目录基于目标项目的源项和修饰符键的性质的拖放 （以及剪切/复制/粘贴） 操作︰  
  
| 修饰符 | 类别 | 源项︰ 引用/链接 | 源项︰ 物理项或文件系统 (`CF_HDROP`) |  
| --- | --- | --- | --- |  
| 没有修饰符 | 操作 | 移动 | 移动 |  
| 没有修饰符 | 目标 | 到的目标位置的副本项 | 到的目标位置的副本项 |  
| 没有修饰符 | 源 | 删除对原始项目的引用 | 删除对原始项目的引用 | | 没有修饰符 | 结果 | `DROPEFFECT_MOVE`作为从操作返回`::Drop`并项保留在存储中的原始位置 | `DROPEFFECT_MOVE`作为从操作返回`::Drop`并项保留在存储中的原始位置 |  
| 按住 shift + 拖动 | 操作 | 移动 | 移动 |  
| 按住 shift + 拖动 | 目标 | 到的目标位置的副本项 | 到的目标位置的副本项 |  
| 按住 shift + 拖动 | 源 | 删除对原始项目的引用 | 从原始位置删除项 |
| 按住 shift + 拖动 | 结果 | `DROPEFFECT_MOVE`作为从操作返回`::Drop`并项保留在存储中的原始位置 | `DROPEFFECT_MOVE`作为从操作返回`::Drop`并项保留在存储中的原始位置 |  
| Ctrl + 拖 | 操作 | 复制 | 复制 |  
| Ctrl + 拖 | 目标 | 到的目标位置的副本项 | 到的目标位置的副本项 |  
| Ctrl + 拖 | 源 | 保留原始项目引用 | 保留原始项目引用 |  
| Ctrl + 拖 | 结果 | `DROPEFFECT_COPY`作为从操作返回`::Drop`并项保留在存储中的原始位置 | `DROPEFFECT_COPY`作为从操作返回`::Drop`并项保留在存储中的原始位置 |  
| Ctrl + Shift + 拖 | | 不拖放 | 不拖放 |  
| 剪切/粘贴 | 操作 | 移动 | 移动 |  
| 剪切/粘贴 | 目标 | 到的目标位置的副本项 | 到的目标位置的副本项 |  
| 剪切/粘贴 | 源 | 删除对原始项目的引用 | 从原始位置删除项 |  
| 剪切/粘贴 | 结果 | 项目仍保留在存储中的原始位置 | 从存储中的原始位置中删除项目 |  
| 复制/粘贴 | 操作 | 复制 | 复制 |  
| 复制/粘贴 | 目标 | 将引用添加到原始项目 | 到的目标位置的副本项 |  
| 复制/粘贴 | 源 | 保留原始项目 | 保留原始项目 |  
| 复制/粘贴 | 结果 | 项目仍保留在存储中的原始位置 | 项保留在原始位置单元存储 |
  
#### <a name="mixed-target-projects"></a>混合目标项目  
下表总结了应执行基于对于混合目标项目按下的源项和修饰符键的性质的拖放 （以及剪切/复制/粘贴） 操作︰  
  
| 修饰符 | 类别 | 源项︰ 引用/链接 | 源项︰ 物理项或文件系统 (`CF_HDROP`) |  
| --- | --- | --- | --- |
| 没有修饰符 | 操作 | 移动 | 移动 |
| 没有修饰符 | 目标 | 将引用添加到原始项目 | 到的目标位置的副本项 |
| 没有修饰符 | 源 | 删除对原始项目的引用 | 删除对原始项目的引用 |
| 没有修饰符 | 结果 | `DROPEFFECT_ MOVE`作为从操作返回`::Drop`并项保留在存储中的原始位置 | `DROPEFFECT_ MOVE`作为从操作返回`::Drop`和从存储中的原始位置中删除项目 |
| 按住 shift + 拖动 | 操作 | 移动 | 移动 |
| 按住 shift + 拖动 | 目标 | 将引用添加到原始项目 | 到的目标位置的副本项 |
| 按住 shift + 拖动 | 源 | 删除对原始项目的引用 | 从原始位置删除项 | 
| 按住 shift + 拖动 | 结果 | `DROPEFFECT_ MOVE`作为从操作返回`::Drop`并项保留在存储中的原始位置 | `DROPEFFECT_ MOVE`作为从操作返回`::Drop`和从存储中的原始位置中删除项目 |
| Ctrl + 拖 | 操作 | 复制 | 复制 |
| Ctrl + 拖 | 目标 | 将引用添加到原始项目 | 到的目标位置的副本项 |
| Ctrl + 拖 | 源 | 保留原始项目引用 | 保留原始项目 |
| Ctrl + 拖 | 结果 | `DROPEFFECT_ COPY`作为从操作返回`::Drop`并项保留在存储中的原始位置 | `DROPEFFECT_ COPY`作为从操作返回`::Drop`并项保留在存储中的原始位置 |
| Ctrl + Shift + 拖 | 操作 | 链接 | 链接 |
| Ctrl + Shift + 拖 | 目标 | 将引用添加到原始项目 | 将引用添加到原始的源项 |
| Ctrl + Shift + 拖 | 源 | 保留原始项目引用 | 保留原始项目 |
| Ctrl + Shift + 拖 | 结果 | `DROPEFFECT_ LINK`作为从操作返回`::Drop`并项保留在存储中的原始位置 | `DROPEFFECT_ LINK`作为从操作返回`::Drop`并项保留在存储中的原始位置 |
| 剪切/粘贴 | 操作 | 移动 | 移动 |
| 剪切/粘贴 | 目标 | 到的目标位置的副本项 | 到的目标位置的副本项 |
| 剪切/粘贴 | 源 | 删除对原始项目的引用 | 从原始位置删除项 |
| 剪切/粘贴 | 结果 | 项目仍保留在存储中的原始位置 | 从存储中的原始位置中删除项目 |
| 复制/粘贴 | 操作 | 复制 | 复制 |
| 复制/粘贴 | 目标 | 将引用添加到原始项目 | 到的目标位置的副本项 |
| 复制/粘贴 | 源 | 保留原始项目 | 保留原始项目 |
| 复制/粘贴 | 结果 | 项目仍保留在存储中的原始位置 | 项目仍保留在存储中的原始位置 |
  
这些详细信息应该考虑在内，在实现拖动时**解决方案资源管理器**:  
  
-   设计为多选择方案。  
  
-   在目标项目的文件名 （完整路径） 必须是唯一或不应允许删除。  
  
-   文件夹名称必须唯一 （不区分大小写） 将被丢弃 — 它们级别。  
  
-   有在 （上面的方案中未提及） 的拖动时是打开还是关闭的文件之间的行为差异。  
  
-   顶级文件行为略有不同文件夹中的文件。  
  
另一个问题，需要注意的是如何处理具有打开的设计器或编辑器项上的移动操作。 预期的行为是，如下所示 （这适用于所有项目类型）︰  
  
1.  如果打开编辑器/设计器不具有任何未保存的更改，然后编辑器/设计器应以无提示方式关闭窗口。  
  
2.  如果打开编辑器/设计器也有未保存的更改，拖动源应等待下拉以发生然后要求用户在关闭与类似于下面的提示窗口前保存打开的文档中的未提交的更改︰  
  
    ```  
    ==========================================================   
         One or more open documents have unsaved changes.  
    Do you want to save uncommitted changes before proceeding?   
                      [Yes]  [No]  [Cancel]   
    ==========================================================  
    ```  
  
这使用户有机会在目标进行其副本之前保存正在进行的工作。 新方法`IVsHierarchyDropDataSource2::OnBeforeDropNotify`要启用此处理已添加。  
  
目标然后将按原样存储中复制的项的状态 (不包括在编辑器中未保存的更改，如果用户选择**否**)。 目标已完成其复制后 (在`IVsHierarchyDropDataSource::Drop`)，源有机会在完成移动操作的删除部分 (在`IVsHierarchyDropDataSource::OnDropNotify`)。  
  
未保存的更改与任何编辑器应保持打开状态。 对于这些文档的未保存的更改，这意味着，将执行移动操作的复制部分，但会中止删除部分。 当用户选择多个选择方案中**否**，这些文档的未保存的更改不应关闭或删除，但未保存的更改不应将关闭和删除。
